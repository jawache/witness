# Witness Development Log

This log chronicles the development journey of Witness, an Obsidian plugin that implements the Model Context Protocol (MCP) to enable AI-assisted vault management.

---

## 2026-01-30 - Phase 1: MCP Server Implementation

**Objective**: Create an Obsidian plugin that acts as an MCP server running inside Obsidian, enabling Claude Desktop to interact with the vault.

### What We Built

Implemented a complete MCP server with 6 core tools:

1. **read_file** - Read any file from the vault
2. **write_file** - Create or modify files
3. **list_files** - Browse directory contents
4. **edit_file** - Find and replace text (surgical edits)
5. **search** - Full-text search across all markdown files
6. **execute_command** - Execute any Obsidian command by ID

### The Journey

**Morning: Architecture Decision**

Started with a critical architectural choice: Should the plugin BE the MCP server (Approach A) or should it be an external server connecting via REST API (Approach B)?

Decision: **Approach A** - Plugin runs the MCP server directly inside Obsidian. This means:
- Zero dependencies on other plugins
- Direct access to Obsidian's Vault API
- HTTP server running in Electron process
- More complex but more powerful

**Early Development: Initial Implementation**

First attempt was manual JSON-RPC message handling. Messy and error-prone. Quickly pivoted to using the official `@modelcontextprotocol/sdk` package for proper protocol compliance.

Initial tools: read_file, write_file, list_files working with manual testing via curl.

**The Great Session Management Mystery**

Hit a major blocker: "Server already initialized" error on every connection attempt from Claude Desktop. Spent considerable time investigating:

1. **Red Herring #1**: Node version issues
   - mcp-remote showed "File is not defined" errors
   - Tried forcing Node v24 via PATH environment
   - Turned out to be irrelevant - still works with Node v18

2. **The Real Problem**: Session Management
   - Was creating a new transport for EVERY HTTP request
   - Should create ONE transport per SESSION
   - Maintain a `Map<sessionId, transport>`
   - Only call `mcpServer.connect(transport)` once per session
   - Reuse transport for all subsequent requests in that session

**Breakthrough**: Found the pattern in SDK examples at `node_modules/@modelcontextprotocol/sdk/dist/esm/examples/server/simpleStreamableHttp.js`. The key insight: StreamableHTTP is stateful. Sessions span multiple HTTP requests.

**Second Major Issue**: SSE Stream 404 Errors

Tools were listing successfully, but then Claude Desktop couldn't establish the SSE (Server-Sent Events) stream for receiving notifications.

Problem: Only handling POST requests to `/mcp`, not GET requests.

Solution: StreamableHTTP uses dual endpoints:
- POST for sending JSON-RPC messages
- GET for SSE streams (receiving)

Also had to handle GET requests differently - no body to parse.

**Late Afternoon: Completing the Tool Set**

With the connection working, implemented the remaining three tools:

1. **edit_file**: Find/replace with proper regex escaping for literal matching
2. **search**: Full-text search with optional case sensitivity and path filtering
3. **execute_command**: Direct access to Obsidian's command system

All tools use Zod schemas for parameter validation, letting the SDK auto-generate JSON Schema.

### Technical Achievements

- **Proper Session Management**: Map-based transport tracking
- **SSE Support**: Bidirectional communication working
- **Type Safety**: Zod validation for all parameters
- **Error Handling**: Clear error messages with helpful suggestions
- **Zero External Dependencies**: No REST API plugins needed

### Documentation Created

- **README.md**: User-facing installation and usage guide
- **CLAUDE.md**: Technical implementation details for AI assistants
- **PHASE1-COMPLETE.md**: Comprehensive tool reference with examples
- **test-tools.sh**: Testing verification script
- **DEVLOG**: This file

### Key Learnings

1. **StreamableHTTP is stateful**: Don't create new transports per request
2. **Dual endpoints matter**: Handle both POST and GET for full functionality
3. **Read the SDK examples**: The answers are often in the source code
4. **Test methodically**: Health endpoint + logs + screenshots = debugging trinity
5. **Document as you go**: Future you will thank present you

### Statistics

- **4 commits** in main branch
- **452 lines** of TypeScript
- **6 tools** implemented
- **100%** Phase 1 objectives met

### Next Steps

Phase 2: Remote Access
- Cloudflare Tunnel integration
- WhatsApp/Telegram bot connection
- Mobile support
- Multi-user authentication
- Security hardening

### Reflections

The session management bug was frustrating but educational. It reinforced the importance of:
- Reading official examples thoroughly
- Not assuming the first error message is the real problem
- Systematic debugging rather than guessing
- Writing documentation that captures the "why" not just the "what"

Phase 1 is complete and working beautifully. The foundation is solid for Phase 2 expansion.

---

## 2026-01-31 - Integration Test Suite

**Objective**: Build automated testing infrastructure to verify MCP tools work correctly end-to-end.

### What We Built

A complete integration test suite using Vitest that tests all MCP tools against a running Obsidian instance.

**Test Infrastructure:**
- `test/vault/` - Minimal, stable test vault with known fixed content
- `test/integration/mcp-client.ts` - MCP protocol client for testing
- `test/integration/mcp.test.ts` - 17 integration tests covering all tools
- `test/vitest.config.ts` - Test configuration

**Vault Reorganization:**
- Renamed `test-vault/` → `demo-vault/` for manual testing and development
- Created `test/vault/` for automated tests (port 3001)
- Clear separation: demo vault can change freely, test vault stays stable

**NPM Scripts:**
- `npm test` - Run integration tests
- `npm run test:watch` - Watch mode
- `npm run test:start-obsidian` - Launch Obsidian with test vault
- `npm run test:install-plugin` - Build and install plugin

### The Journey

**Design Decision: Integration vs Unit Tests**

Considered two approaches:
1. Mock-based unit tests - Fast but doesn't test real integration
2. Integration tests against running Obsidian - Slower but tests actual behavior

Chose integration tests because:
- Most plugin logic is tightly coupled to Obsidian's API
- Mocking the vault would be complex and fragile
- We need to verify files are actually created/modified
- MCP protocol nuances are hard to unit test

**Test Verification Strategy**

Made sure tests actually verify results, not just check for errors:
- `write_file`: Writes content, then reads it back to verify
- `edit_file`: Performs edit, then reads file to confirm change
- `read_file`: Checks returned content matches known file content
- `search`: Verifies correct files appear in results

**Initial Test Failures**

First run: 14/17 tests passed. The 3 failures were because MCP returns errors via `isError: true` flag rather than throwing exceptions. Updated tests to check `result.isError` instead of `expect(...).rejects.toThrow()`.

Second run: 17/17 tests pass.

### Technical Achievements

- **True End-to-End Testing**: Tests run against real Obsidian instance
- **All Tools Covered**: 17 tests for 8 MCP tools
- **Error Case Coverage**: Tests both success and error paths
- **Result Verification**: Tests read back data to verify operations worked
- **Clean Separation**: Test vault isolated from demo/development vault

### Test Coverage Summary

| Tool | Tests | Verification |
|------|-------|--------------|
| read_file | 2 | Content matches known file |
| write_file | 2 | Read back verifies content |
| edit_file | 2 | Read back verifies changes |
| list_files | 2 | Expected files present |
| search | 2 | Correct files in results |
| find_files | 2 | Pattern matching works |
| get_orientation | 1 | Returns orientation doc |
| execute_command | 2 | Success/error handling |

### Key Learnings

1. **MCP error handling**: Errors return `isError: true`, not exceptions
2. **TypeScript config**: Need to exclude test directory from main build
3. **Vitest config**: `sequence.concurrent: false` for sequential tests
4. **Port separation**: Test vault uses 3001 to avoid conflicts with demo

### Statistics

- **17 tests** all passing
- **166ms** test duration
- **2 vaults** (demo + test)
- **4 npm scripts** for testing workflow

### Next Steps

- Consider adding GitHub Actions CI
- Add more edge case tests as bugs are found
- Potential: Screenshot tests for UI verification

---

## 2026-01-31 - File-Based MCP Logging

**Objective**: Implement file-based logging so logs are accessible without Obsidian's Developer Console.

### What We Built

A logging system that writes MCP server logs to files in the plugin directory.

**MCPLogger Class:**

- Writes to both console AND file simultaneously
- Buffered writes (flushes every 1 second or 50 entries)
- Date-based log files: `mcp-YYYY-MM-DD.log`
- Log levels: INFO, ERROR, DEBUG, MCP
- ISO timestamps for all entries
- Graceful shutdown flushes remaining logs

**Log Location:**

```text
.obsidian/plugins/witness/logs/mcp-2026-01-31.log
```

**Log Format:**

```text
[2026-01-31T17:49:56.003Z] [INFO] Witness plugin loaded
[2026-01-31T17:50:07.214Z] [MCP] POST /mcp
[2026-01-31T17:50:07.242Z] [MCP] read_file called with path: "test.md"
```

### Benefits

1. **Debugging**: Claude Code can read logs directly to help debug issues
2. **Bug Reports**: Users can easily share logs when reporting problems
3. **No Console Required**: No need to open Developer Console to see what's happening
4. **History**: Date-based files provide historical record

### Testing

Added 2 new integration tests (now 19 total):

1. **should write logs to file** - Verifies log file exists and contains expected entries
2. **should log error cases** - Verifies failed operations are logged

### Implementation Details

Replaced all `console.log` and `console.error` calls with `this.logger.*` calls:

- `this.logger.info()` - General information
- `this.logger.error()` - Error conditions
- `this.logger.debug()` - Debug info
- `this.logger.mcp()` - MCP protocol-level logging

The logger buffers writes to avoid I/O overhead on every log call.

### Statistics

- **2 new tests** added
- **19 tests** total, all passing
- **~150 lines** of logging code
- **1 new class** (MCPLogger)

### Next Steps

- Implement `move_file` tool for moving/renaming files
- Consider log rotation for large vaults

---

## 2026-01-31 - Move/Rename File Tool

**Objective**: Implement `move_file` MCP tool to move or rename files within the vault.

### What We Built

A new `move_file` MCP tool that enables AI assistants to move or rename files within the vault using Obsidian's native `vault.rename()` API.

**Tool Implementation:**

- Takes `from` (source path) and `to` (destination path) parameters
- Uses Obsidian's `vault.rename()` for proper file system handling
- Automatically creates parent directories if needed
- Error handling for: source not found, destination already exists
- Marked as destructive (destructiveHint: true)
- Full logging integration

**Test Coverage:**

Added 4 new integration tests (23 total):
1. Should move/rename a file
2. Should move file to subfolder
3. Should return error for non-existent source
4. Should return error if destination exists

### Technical Details

```typescript
this.mcpServer.tool(
  'move_file',
  'Move or rename a file within the vault',
  {
    from: z.string().describe('Current path of the file'),
    to: z.string().describe('New path for the file'),
  },
  { destructiveHint: true },
  async ({ from, to }) => {
    const file = this.app.vault.getAbstractFileByPath(from);
    if (!file) throw new Error(`Source file not found: ${from}`);

    const existing = this.app.vault.getAbstractFileByPath(to);
    if (existing) throw new Error(`Destination already exists: ${to}`);

    // Create parent directories if needed
    const destDir = to.substring(0, to.lastIndexOf('/'));
    if (destDir) {
      const parentFolder = this.app.vault.getAbstractFileByPath(destDir);
      if (!parentFolder) {
        await this.app.vault.createFolder(destDir);
      }
    }

    await this.app.vault.rename(file, to);
    return { content: [{ type: 'text', text: `Moved ${from} to ${to}` }] };
  }
);
```

### Key Features

- **Preserves Metadata**: Unlike delete + create, rename preserves file creation date and other metadata
- **Parent Directory Creation**: Automatically creates destination directories if they don't exist
- **Conflict Prevention**: Fails safely if destination already exists
- **Full Logging**: Integrated with MCPLogger for debugging

### Statistics

- **4 new tests** added
- **23 tests** total, all passing
- **~50 lines** of new tool code
- **9 MCP tools** now available

### Next Steps

- Remote Access via Cloudflare Tunnel (Phase 2)

---

## 2026-01-31 - Cloudflare Quick Tunnel Integration

**Objective**: Enable remote access to the Witness MCP server via Cloudflare's Quick Tunnel feature.

### What We Built

A complete tunneling solution that exposes the local MCP server to the internet, allowing Claude to connect from anywhere.

**Key Features:**

- **Zero-Config Tunneling**: Toggle "Enable Quick Tunnel" in settings and get a public URL
- **Auto-Install**: cloudflared binary automatically downloads on first use to `~/.witness/bin/`
- **Settings UI**: Display current URL with copy button, regenerate button, status indicator
- **Notifications**: Toast notification when tunnel connects with URL

**Architecture:**

```text
Claude (anywhere)
    ↓ HTTPS
Cloudflare Edge (random-words.trycloudflare.com)
    ↓ Tunnel
cloudflared binary (running on user's machine)
    ↓ HTTP
Witness Plugin (localhost:3000)
    ↓
Obsidian Vault
```

### The Journey

**Challenge: Binary Path Resolution**

Initial attempt failed with:

```text
spawn /Applications/Obsidian.app/Contents/Resources/electron.asar/bin/cloudflared ENOENT
```

The cloudflared npm package couldn't find its binary inside Obsidian's Electron environment. The package looks for the binary relative to its module location, but bundling breaks this.

**Solution: Custom Binary Management**

1. Install cloudflared to a known, stable location: `~/.witness/bin/cloudflared`
2. Use the package's `use()` function to point to our binary location
3. Handle first-run installation automatically

```typescript
private getCloudflaredBinPath(): string {
  const binDir = path.join(os.homedir(), '.witness', 'bin');
  return path.join(binDir, 'cloudflared');
}

await installCloudflared(binPath);  // Install to our location
useCloudflared(binPath);            // Tell package where to find it
```

**esbuild Configuration**

Also needed to update `esbuild.config.mjs` to handle `node:` prefixed module specifiers:

```javascript
const nodeBuiltins = builtins.flatMap(m => [m, `node:${m}`]);
// Add platform: "node" for proper Node.js target
```

### Implementation Details

**Settings Interface:**

```typescript
interface WitnessSettings {
  // ... existing
  enableTunnel: boolean;
  tunnelUrl: string | null;
}
```

**Tunnel Lifecycle:**

1. On plugin load: Start tunnel if enabled
2. On plugin unload: Stop tunnel gracefully
3. Regenerate: Stop, wait, restart

**Event Handling:**

```typescript
const tunnel = Tunnel.quick(localUrl);
tunnel.once('url', async (url) => {
  this.settings.tunnelUrl = url;
  await this.saveSettings();
  new Notice(`Tunnel connected: ${url}/mcp`);
});
tunnel.once('connected', (conn) => {
  this.logger.info(`Connected to ${conn.location}`);
});
tunnel.on('exit', (code) => {
  this.tunnelProcess = null;
  this.tunnelStatus = 'disconnected';
});
```

### Testing

Verified end-to-end:

```bash
# Health check through tunnel
curl https://bought-funky-charges-reservation.trycloudflare.com/health
# {"status":"ok","plugin":"witness"}

# MCP initialize through tunnel
curl -X POST .../mcp -H "Accept: application/json, text/event-stream" -d '...'
# {"result":{"protocolVersion":"2024-11-05",...}}
```

### Key Learnings

1. **Electron bundling breaks module paths**: Can't rely on npm package default paths inside Obsidian
2. **Quick Tunnels are truly zero-config**: No Cloudflare account needed
3. **Binary installation is idempotent**: Package handles version checking
4. **URL changes on restart**: Users must reconfigure Claude after Obsidian restart

### Statistics

- **1 npm package** added (cloudflared)
- **~150 lines** of tunnel code
- **4 new settings** (enableTunnel, tunnelUrl, status, UI elements)
- **~50MB** cloudflared binary (downloaded on first use)

### Next Steps

- Authentication token enforcement for tunnel
- WhatsApp/Telegram bot integration
- Permanent URLs via Named Tunnel (documentation)

---

## 2026-02-01 - Token Authentication for Remote Access

**Objective**: Implement simple token-based authentication to protect the MCP endpoint when exposed via Cloudflare tunnel.

### What We Built

A simplified authentication system that protects remote access with a token, replacing the initial OAuth 2.0 implementation that proved incompatible with Claude Desktop.

**Key Features:**

- **Query Parameter Token**: Access via `?token=xxx` in the URL
- **Authorization Header**: Also accepts `Authorization: Bearer xxx`
- **Auto-Generate Token**: Token created automatically when enabling auth
- **Settings UI**: Token field with regenerate button under Remote Access section
- **URL Integration**: MCP URL displays with token included when auth is enabled

### The Journey

**Initial Approach: OAuth 2.0 Client Credentials**

Started implementing full OAuth 2.0 Client Credentials Grant:
- Added `/.well-known/oauth-authorization-server` metadata endpoint
- Implemented `/oauth/token` endpoint
- Generated client ID and secret on first run
- Token issuance with expiration

**The Problem: Claude Desktop OAuth Requirements**

Discovered through web research that Claude Desktop requires OAuth 2.1 Authorization Code flow with PKCE, not the simpler Client Credentials grant we implemented. Claude's MCP authentication is designed for delegated authorization scenarios, not machine-to-machine authentication.

Key findings:
- Claude expects a full OAuth 2.1 flow with user consent screens
- Client Credentials grant (machine-to-machine) isn't supported
- Known bugs with OAuth in Claude Desktop as of late 2025

**The Pivot: Simple Token Authentication**

Decided to simplify to a query parameter token approach:

1. **Security Trade-off**: Query params in HTTPS are encrypted in transit, but may appear in logs. Acceptable for personal vaults.
2. **Dual Support**: Accept token via query param OR Authorization header for flexibility
3. **UI Integration**: Token shown in the MCP URL for easy copy-paste

### Technical Achievements

**Token Validation Logic:**

```typescript
private validateAuth(req: IncomingMessage): boolean {
  const expectedToken = this.settings.authToken;

  // Check query parameter
  const url = new URL(req.url || '', `http://localhost:${port}`);
  const queryToken = url.searchParams.get('token');
  if (queryToken === expectedToken) return true;

  // Check Authorization header
  const authHeader = req.headers['authorization'];
  if (authHeader?.split(' ')[1] === expectedToken) return true;

  return false;
}
```

**Settings UI Changes:**

- Moved "Require Authentication" toggle under Remote Access section
- Only shows when tunnel is enabled (auth without tunnel is pointless)
- Token field with regenerate button appears when auth is enabled
- MCP URL automatically includes `?token=xxx` when both tunnel and auth are enabled

### Key Learnings

1. **Claude OAuth is complex**: Claude Desktop expects full OAuth 2.1 with PKCE, not simple client credentials
2. **Simple beats complex**: For personal use, a query parameter token is perfectly adequate
3. **HTTPS protects query params**: Query strings are encrypted in transit, only visible in logs
4. **UI flow matters**: Showing the complete URL with token makes copy-paste seamless

### Statistics

- **~100 lines removed** (OAuth complexity)
- **~50 lines added** (simple token auth)
- **1 new setting** (moved authToken under Remote Access)
- **Net simplification**: Fewer endpoints, cleaner code

### Next Steps

- WhatsApp/Telegram bot integration
- Permanent URLs via Named Tunnel (documentation)
- Consider rate limiting for public exposure

---

## 2026-02-01 - GitHub Repository & First Release

**Objective**: Publish the Witness plugin to GitHub and create the first release for BRAT installation.

### What We Built

Made Witness publicly available on GitHub with a proper release for easy installation.

**Repository**: [github.com/jawache/witness](https://github.com/jawache/witness)

**Release**: v0.1.0 - Initial Release

### Release Contents

The v0.1.0 release includes:

- `main.js` - Compiled plugin code (~2MB)
- `manifest.json` - Plugin metadata

**Features in this release:**

- 9 MCP tools (read_file, write_file, list_files, edit_file, search, find_files, move_file, execute_command, get_vault_context)
- Cloudflare Quick Tunnel for remote access
- Token authentication for secure remote connections
- Claude Desktop integration via mcp-remote bridge
- File-based logging
- Full settings UI

### Installation via BRAT

Users can now install Witness easily using the BRAT plugin:

1. Install BRAT from Community Plugins
2. Add Beta Plugin: `jawache/witness`
3. Enable Witness in Community Plugins

BRAT handles downloading the release assets and installing them in the correct location.

### Documentation Updates

Updated README.md with:

- BRAT installation instructions (recommended method)
- Manual installation from releases
- Build from source instructions
- Clear separation of installation methods

### Statistics

- **1 GitHub repository** created
- **1 release** (v0.1.0) published
- **2 release assets** (main.js, manifest.json)
- **README.md** updated with new installation options

### Next Steps

- Submit to Obsidian Community Plugins (requires review)
- WhatsApp/Telegram bot integration
- Permanent URLs via Named Tunnel

---

## 2026-02-01 - Semantic Search Implementation (PAUSED)

**Objective**: Add semantic search capability that finds files by meaning, not just keywords, leveraging Smart Connections embeddings.

**Status**: ⏸️ PAUSED - ONNX WASM runtime doesn't initialize properly in Obsidian's Electron environment. Code preserved in `feature/semantic-search` branch.

### What We Built

Implemented a `semantic_search` MCP tool that:
- Generates query embeddings using transformers.js with `TaylorAI/bge-micro-v2` model
- Loads pre-computed embeddings from Smart Connections' `.smart-env/multi/*.ajson` files
- Calculates cosine similarity between query and document vectors
- Returns ranked list of semantically similar files

### The Journey

**Research Phase: Smart Connections Integration**

Initially explored calling Smart Connections APIs directly, but discovered:
- Obsidian commands are fire-and-forget (no return values)
- Smart Connections doesn't expose a programmatic search API
- Other MCP servers that integrate with SC all read the `.ajson` files directly

This led to the decision to bundle transformers.js and generate query embeddings ourselves.

**The Build Challenge: Native ONNX Bindings**

First attempt with `@xenova/transformers` failed to build:
- ES2018 target doesn't support BigInt literals (used by ONNX)
- Native `.node` files can't be bundled by esbuild
- Same issues with `@huggingface/transformers`

**Solution: Browser Platform + WASM**

Updated esbuild configuration:
- Changed `platform` from "node" to "browser"
- Upgraded `target` to "es2020" for BigInt support
- Added `conditions: ["browser", "import"]` for WASM version
- Aliased `onnxruntime-node` to `onnxruntime-web`
- Marked native modules as external

This forces transformers.js to use the WebAssembly backend instead of native ONNX bindings, which works in Obsidian's Electron environment.

### Implementation Details

**Helper Methods:**
- `initEmbedder()` - Lazy-loads transformers.js pipeline on first use
- `cosineSimilarity()` - Vector similarity calculation
- `loadSmartConnectionsEmbeddings()` - Parses SC's `.ajson` format with caching
- `clearEmbeddingsCache()` - Manual cache invalidation if needed

**The semantic_search Tool:**
```typescript
semantic_search(query: string, limit?: number)
// Returns: List of files ranked by semantic similarity
// Example: "productivity systems" → finds notes about GTD, time management, etc.
```

### Technical Achievements

- Successfully bundled transformers.js (4.2MB) for Obsidian
- Compatible with Smart Connections' embedding format
- Lazy loading prevents startup delay
- Embeddings cached for fast subsequent searches

### Key Learnings

1. **Platform matters**: esbuild's `platform: "browser"` + conditions can force WASM builds
2. **ES target versions**: BigInt requires ES2020 minimum
3. **Smart Connections format**: AJSON files store embeddings keyed by `TaylorAI/bge-micro-v2`
4. **Obsidian = Electron**: Browser APIs available, but Node.js require() still works

### Statistics

- **1 new MCP tool**: semantic_search
- **4 helper methods** added
- **Bundle size**: 4.2MB (increased from transformers.js)
- **10 total MCP tools** now available

### Why Paused

Despite successful bundling, the ONNX WASM runtime fails to initialize in Obsidian's Electron environment:

```text
TypeError: Cannot read properties of undefined (reading 'create')
at createInferenceSession
```

The model downloads correctly but `InferenceSession.create()` fails. The WASM files aren't loading properly in Electron's sandboxed environment.

### Code Preserved

All semantic search code is in the `feature/semantic-search` branch for future work when we find a solution.

### Potential Future Approaches

- Run embeddings in a separate Node.js process
- Use a different model format (GGML/llama.cpp)
- Wait for better Electron/WASM compatibility
- External embedding service

---

## 2026-02-03 - Semantic Search WASM Deep Dive

**Objective**: Get WASM-based embeddings working in Obsidian for semantic search

### What We Tried

Continued investigation into running transformers.js/ONNX in Obsidian's Electron environment. Systematically tested multiple approaches:

1. **Web Worker with bundled transformers.js**
   - Model downloads successfully (0-100%)
   - Fails at ONNX session creation: "no available backend found"

2. **Direct main thread with bundled transformers.js**
   - TypeScript errors with fileURLToPath resolution
   - Electron's hybrid Node.js/browser environment confuses module resolution

3. **Dynamic import from CDN**
   - `import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2')`
   - Works in Electron's renderer process
   - Model downloads successfully
   - Same ONNX session creation failure: "Cannot read properties of undefined (reading 'create')"

4. **Preloading onnxruntime-web separately**
   - Load onnxruntime-web via script tag before transformers.js
   - Set WASM paths explicitly
   - Still fails at InferenceSession.create()

5. **Various env configurations**
   - `env.allowLocalModels = false`
   - `env.useBrowserCache = true`
   - `env.backends.onnx.wasm.wasmPaths = CDN_URL`
   - None resolved the core issue

### Root Cause Analysis

The fundamental problem is that **Obsidian's Electron renderer process is a hybrid Node.js/browser environment** that confuses ONNX runtime's backend selection:

1. ONNX detects Node.js APIs are available → tries Node backend
2. Node backend requires native binaries → fails
3. Falls back to WASM backend
4. WASM backend can't initialize properly because of hybrid environment
5. `InferenceSession.create` becomes undefined

This is a **known limitation** with transformers.js in Electron environments. The library is designed for either pure Node.js OR pure browser, not Electron's hybrid.

### THE SOLUTION: Iframe Isolation

After examining the Smart Connections plugin codebase (which does WASM embeddings successfully), found the key insight: **use a hidden iframe to provide a clean browser context**.

**How it works:**
1. Create a hidden iframe with `srcdoc` containing a module script
2. The iframe runs in a pure browser context without Node.js APIs
3. Load transformers.js from CDN inside the iframe
4. Communicate via `postMessage` between main plugin and iframe
5. WASM initializes successfully in the clean browser environment!

**Implementation:**
```typescript
// Create hidden iframe
this.iframe = document.createElement('iframe');
this.iframe.style.display = 'none';
this.iframe.srcdoc = `
  <script type="module">
    const transformers = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.8.0');
    // ... pipeline initialization works here!
  </script>
`;
document.body.appendChild(this.iframe);
```

**Results:**
- ✅ Model downloads successfully
- ✅ WASM/ONNX runtime initializes
- ✅ Embeddings generated (384 dimensions)
- ✅ Sub-second response time after initial load

### Code Changes

- Created `embedding-service-iframe.ts` with iframe-based approach
- Uses `@huggingface/transformers@3.8.0` from CDN
- Tries WebGPU first, falls back to WASM
- Updated `main.ts` to use `EmbeddingServiceIframe`

### Key Learning

**The iframe isolation pattern is the solution for running WASM in Obsidian plugins.** The iframe provides a clean browser environment where:
- No Node.js APIs pollute the global scope
- Module resolution follows browser rules
- WASM backend initialization works correctly

Credit to Smart Connections for pioneering this approach!

### Next Steps

1. ✅ WASM embeddings working via iframe
2. Phase B: Implement storage & indexing in .witness/
3. Phase C: Complete semantic_search tool with actual document search
4. Phase D: Settings UI for semantic search
5. Phase E: Obsidian Leaf View UI

---

## 2026-02-04 - Semantic Search Complete: Storage, Indexing & Search

**Objective**: Complete the semantic search implementation with document indexing, storage, and actual search functionality.

### What We Built

Completed the full semantic search pipeline:

1. **EmbeddingIndex** (`src/embedding-index.ts`)
   - Storage in `.witness/embeddings/` folder
   - Index metadata tracking model, version, document count
   - Per-file vector storage in `vectors/` subdirectory
   - Cosine similarity search with filtering by tags/paths
   - Incremental update support

2. **DocumentIndexer** (`src/document-indexer.ts`)
   - Hierarchical chunking: document-level + H2 section embeddings
   - Front matter extraction (tags, title)
   - Content hashing for change detection
   - Progress callbacks for UI feedback

3. **MCP Tools**
   - `semantic_search` - Find documents by meaning with filters
   - `index_documents` - Build/update the embedding index

4. **Incremental Updates**
   - File change listeners (`modify`, `delete`, `rename`)
   - Automatic re-indexing on file changes
   - Skip unchanged files during batch indexing

### The Journey

**Challenge: Wrong Test Vault**

Spent significant time debugging why `index_documents` tool wasn't appearing. Discovered there were TWO vaults:
- `test-vault/` - where we were copying files
- `test/vault/` - the actual vault open in Obsidian

After copying to the correct location and restarting Obsidian, everything worked immediately.

**Testing the Full Pipeline:**

```bash
# Initialize session
curl -X POST http://localhost:3001/mcp ...

# Index documents - SUCCESS!
{"text":"Indexing complete!\n\n- Indexed: 8 documents\n- Skipped (unchanged): 0\n- Errors: 0\n\nModel: TaylorAI/bge-micro-v2 (384 dimensions)"}

# Search by meaning - SUCCESS!
{"text":"Found 9 result(s) for: \"chaos and order philosophy\"\n\n1. **move-conflict-source** (50.5%)\n..."}
```

The search returns both document-level and section-level results with similarity percentages.

### Achievements

- **Iframe Pattern Works**: transformers.js runs successfully in hidden iframe
- **384-dimension embeddings**: Using TaylorAI/bge-micro-v2 model
- **Sub-second queries**: After initial model load, search is fast
- **Hierarchical results**: Section headings with line numbers returned
- **Filter support**: Can filter by tags and folder paths

### Learnings

1. **Always verify the correct vault**: Development vs test vaults can cause confusion
2. **Obsidian requires full restart**: Copying files isn't enough - JS must be reloaded
3. **Iframe isolation is the key**: Clean browser context for WASM initialization
4. **postMessage for communication**: Simple and reliable across iframe boundary

### Session Stats

- **3 new source files** created
- **~600 lines** of new TypeScript
- **2 new MCP tools** (semantic_search, index_documents)
- **14 total MCP tools** now available
- **8 documents indexed** in test vault

### Files Changed

- `src/embedding-service-iframe.ts` - Iframe WASM embeddings (created earlier)
- `src/embedding-index.ts` - NEW: Storage and search
- `src/document-indexer.ts` - NEW: Document processing
- `src/main.ts` - Updated with new tools and file listeners
- `README.md` - Updated feature list and roadmap
- `CLAUDE.md` - Updated phase status and documentation

### What's Next

- Phase D: Settings UI for semantic search (exclude paths, index status)
- Phase E: Obsidian Leaf View for visual search interface
- Consider: Background indexing on vault open

---

*End of log entry*
